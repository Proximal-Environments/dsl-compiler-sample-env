diff --git a/workspace/code_generator.py b/workspace/code_generator.py
index 0382ebb..8461aa9 100644
--- a/workspace/code_generator.py
+++ b/workspace/code_generator.py
@@ -2,103 +2,19 @@
 Code Generator for SimpleCalc Language
 =======================================
 
-This module should implement a code generator that converts an AST into
+This module implements a code generator that converts an AST into
 assembly code for the SimpleVM architecture.
 
 INPUT: AST dictionary (from parser.py)
 OUTPUT: Assembly code string (for SimpleVM)
 
 The instruction set is defined in task/instruction-set.txt
-
-IMPORTANT: The agent must implement the `generate` function below.
 """
 
 from typing import Any
 
 # ==============================================================================
-# SimpleVM Instruction Reference (see task/instruction-set.txt for details)
-# ==============================================================================
-#
-# Data Movement:
-#   LOAD Rd, #imm       - Load immediate into register
-#   LOAD Rd, [addr]     - Load from memory
-#   STORE Rs, [addr]    - Store to memory
-#   MOV Rd, Rs          - Copy register
-#
-# Arithmetic:
-#   ADD Rd, Rs1, Rs2    - Rd = Rs1 + Rs2
-#   SUB Rd, Rs1, Rs2    - Rd = Rs1 - Rs2
-#   MUL Rd, Rs1, Rs2    - Rd = Rs1 * Rs2
-#   DIV Rd, Rs1, Rs2    - Rd = Rs1 / Rs2
-#   NEG Rd, Rs          - Rd = -Rs
-#
-# Comparison:
-#   CMP Rs1, Rs2        - Compare, set flags
-#
-# Control Flow:
-#   JMP label           - Unconditional jump
-#   JEQ label           - Jump if equal
-#   JNE label           - Jump if not equal
-#   JLT label           - Jump if less than
-#   JGT label           - Jump if greater than
-#   JLE label           - Jump if less or equal
-#   JGE label           - Jump if greater or equal
-#
-# Stack:
-#   PUSH Rs             - Push register to stack
-#   POP Rd              - Pop stack to register
-#
-# I/O:
-#   PRINT Rs            - Output register value
-#
-# Control:
-#   HALT                - Stop execution
-#
-# ==============================================================================
-
-
-def generate(ast: dict[str, Any]) -> str:
-    """
-    Generate assembly code from an AST.
-
-    Args:
-        ast: The AST dictionary from the parser
-
-    Returns:
-        Assembly code string for SimpleVM
-
-    Example:
-        >>> ast = {
-        ...     "type": "Program",
-        ...     "statements": [
-        ...         {
-        ...             "type": "Assignment",
-        ...             "variable": "x",
-        ...             "value": {"type": "Integer", "value": 5}
-        ...         }
-        ...     ]
-        ... }
-        >>> print(generate(ast))
-        LOAD R0, #5
-        STORE R0, [0]
-        HALT
-    """
-    # TODO: Implement this function
-    #
-    # Implementation hints:
-    # 1. Traverse the AST recursively
-    # 2. Maintain a symbol table mapping variable names to memory addresses
-    # 3. Use registers R0-R3 for computation (need register allocation)
-    # 4. Generate appropriate instructions for each AST node type
-    # 5. Handle expression evaluation (may need stack for complex expressions)
-    # 6. Generate labels for control flow (if-else)
-    # 7. Always end with HALT
-    #
-    raise NotImplementedError("Code generator not yet implemented - this is your task!")
-
-
-# ==============================================================================
-# Optional: Helper classes for implementation
+# Symbol Table
 # ==============================================================================
 
 
@@ -124,44 +40,21 @@ class SymbolTable:
         return self.variables[name]
 
 
-class RegisterAllocator:
-    """
-    Simple register allocator for R0-R3.
-
-    Strategy: Use R0 for results, R1-R3 for temporaries.
-    For complex expressions, use the stack.
-    """
-
-    def __init__(self):
-        self.registers = ["R0", "R1", "R2", "R3"]
-        self.in_use = [False, False, False, False]
-
-    def allocate(self) -> str:
-        """Allocate a free register."""
-        for i, used in enumerate(self.in_use):
-            if not used:
-                self.in_use[i] = True
-                return self.registers[i]
-        raise RuntimeError("No free registers - use stack")
-
-    def free(self, reg: str):
-        """Free a register."""
-        idx = self.registers.index(reg)
-        self.in_use[idx] = False
-
-    def free_all(self):
-        """Free all registers."""
-        self.in_use = [False, False, False, False]
+# ==============================================================================
+# Code Generator
+# ==============================================================================
 
 
 class CodeGenerator:
     """
     Generates SimpleVM assembly from AST.
+
+    Uses a stack-based approach for expression evaluation to handle
+    arbitrarily complex expressions with only 4 registers.
     """
 
     def __init__(self):
         self.symbols = SymbolTable()
-        self.registers = RegisterAllocator()
         self.code: list[str] = []
         self.label_counter = 0
 
@@ -181,18 +74,179 @@ class CodeGenerator:
 
     def generate_program(self, ast: dict) -> str:
         """Generate code for the entire program."""
-        # TODO: Implement code generation
-        raise NotImplementedError()
+        assert ast["type"] == "Program"
+
+        for stmt in ast["statements"]:
+            self.generate_statement(stmt)
+
+        self.emit("HALT")
+        return "\n".join(self.code)
 
     def generate_statement(self, stmt: dict):
         """Generate code for a statement."""
-        # TODO: Implement for each statement type
-        raise NotImplementedError()
+        stmt_type = stmt["type"]
+
+        if stmt_type == "Assignment":
+            self._generate_assignment(stmt)
+        elif stmt_type == "Print":
+            self._generate_print(stmt)
+        elif stmt_type == "If":
+            self._generate_if(stmt)
+        else:
+            raise ValueError(f"Unknown statement type: {stmt_type}")
+
+    def _generate_assignment(self, stmt: dict):
+        """Generate code for: variable = expression"""
+        var_name = stmt["variable"]
+        addr = self.symbols.get_address(var_name)
+
+        # Evaluate expression into R0
+        self.generate_expression(stmt["value"], "R0")
+
+        # Store result to memory
+        self.emit(f"STORE R0, [{addr}]")
+
+    def _generate_print(self, stmt: dict):
+        """Generate code for: print(expression)"""
+        # Evaluate expression into R0
+        self.generate_expression(stmt["value"], "R0")
+
+        # Print the result
+        self.emit("PRINT R0")
+
+    def _generate_if(self, stmt: dict):
+        """Generate code for: if (condition) { ... } [else { ... }]"""
+        condition = stmt["condition"]
+        then_body = stmt["then_body"]
+        else_body = stmt["else_body"]
+
+        # Generate labels
+        else_label = self.new_label("else")
+        end_label = self.new_label("endif")
+
+        # Evaluate condition
+        self._generate_condition(condition, else_label)
+
+        # Generate then body
+        for s in then_body:
+            self.generate_statement(s)
+
+        if else_body:
+            self.emit(f"JMP {end_label}")
+
+        # Generate else body
+        self.emit_label(else_label)
+        if else_body:
+            for s in else_body:
+                self.generate_statement(s)
+            self.emit_label(end_label)
+
+    def _generate_condition(self, cond: dict, false_label: str):
+        """Generate code for a condition, jumping to false_label if false."""
+        assert cond["type"] == "Condition"
+
+        # Evaluate left operand into R0
+        self.generate_expression(cond["left"], "R0")
+        # Save R0 to stack
+        self.emit("PUSH R0")
+
+        # Evaluate right operand into R1
+        self.generate_expression(cond["right"], "R1")
+
+        # Restore left operand from stack
+        self.emit("POP R0")
+
+        # Compare
+        self.emit("CMP R0, R1")
+
+        # Jump based on operator (jump if condition is FALSE)
+        op = cond["operator"]
+        if op == "==":
+            self.emit(f"JNE {false_label}")  # Jump if NOT equal
+        elif op == "!=":
+            self.emit(f"JEQ {false_label}")  # Jump if equal
+        elif op == "<":
+            self.emit(f"JGE {false_label}")  # Jump if >= (not less)
+        elif op == ">":
+            self.emit(f"JLE {false_label}")  # Jump if <= (not greater)
+        elif op == "<=":
+            self.emit(f"JGT {false_label}")  # Jump if > (not less or equal)
+        elif op == ">=":
+            self.emit(f"JLT {false_label}")  # Jump if < (not greater or equal)
+        else:
+            raise ValueError(f"Unknown comparison operator: {op}")
 
     def generate_expression(self, expr: dict, target_reg: str):
         """Generate code for an expression, result in target_reg."""
-        # TODO: Implement for each expression type
-        raise NotImplementedError()
+        expr_type = expr["type"]
+
+        if expr_type == "Integer":
+            self.emit(f"LOAD {target_reg}, #{expr['value']}")
+
+        elif expr_type == "Variable":
+            addr = self.symbols.get_address(expr["name"])
+            self.emit(f"LOAD {target_reg}, [{addr}]")
+
+        elif expr_type == "UnaryOp":
+            self._generate_unary_op(expr, target_reg)
+
+        elif expr_type == "BinaryOp":
+            self._generate_binary_op(expr, target_reg)
+
+        else:
+            raise ValueError(f"Unknown expression type: {expr_type}")
+
+    def _generate_unary_op(self, expr: dict, target_reg: str):
+        """Generate code for unary operations."""
+        assert expr["operator"] == "-"  # Only unary minus supported
+
+        # Evaluate operand
+        self.generate_expression(expr["operand"], target_reg)
+
+        # Negate
+        self.emit(f"NEG {target_reg}, {target_reg}")
+
+    def _generate_binary_op(self, expr: dict, target_reg: str):
+        """Generate code for binary operations."""
+        op = expr["operator"]
+        left = expr["left"]
+        right = expr["right"]
+
+        # Evaluate left operand into target register
+        self.generate_expression(left, target_reg)
+
+        # Save left result to stack
+        self.emit(f"PUSH {target_reg}")
+
+        # Evaluate right operand into R1 (or R0 if target is R1)
+        temp_reg = "R1" if target_reg != "R1" else "R0"
+        self.generate_expression(right, temp_reg)
+
+        # Restore left operand from stack into R2
+        self.emit("POP R2")
+
+        # Perform operation: target = left op right
+        op_instr = {"+": "ADD", "-": "SUB", "*": "MUL", "/": "DIV"}[op]
+        self.emit(f"{op_instr} {target_reg}, R2, {temp_reg}")
+
+
+# ==============================================================================
+# Main Generate Function
+# ==============================================================================
+
+
+def generate(ast: dict[str, Any]) -> str:
+    """
+    Generate assembly code from an AST.
+
+    Args:
+        ast: The AST dictionary from the parser
+
+    Returns:
+        Assembly code string for SimpleVM
+    """
+    generator = CodeGenerator()
+    return generator.generate_program(ast)
 
 
 # ==============================================================================
diff --git a/workspace/parser.py b/workspace/parser.py
index 36833e6..393dbc9 100644
--- a/workspace/parser.py
+++ b/workspace/parser.py
@@ -2,91 +2,18 @@
 Parser for SimpleCalc Language
 ==============================
 
-This module should implement a parser that converts source code into an AST.
+This module implements a parser that converts source code into an AST.
 
 INPUT: Source code string (from .src files)
 OUTPUT: AST as a Python dictionary (JSON-serializable)
 
 The AST format is defined in task/grammar.ebnf
-
-IMPORTANT: The agent must implement the `parse` function below.
 """
 
 from typing import Any
 
 # ==============================================================================
-# AST Node Types (for reference)
-# ==============================================================================
-#
-# Program:
-#   { "type": "Program", "statements": [...] }
-#
-# AssignmentStatement:
-#   { "type": "Assignment", "variable": "x", "value": <expression> }
-#
-# PrintStatement:
-#   { "type": "Print", "value": <expression> }
-#
-# IfStatement:
-#   { "type": "If", "condition": <condition>, "then_body": [...], "else_body": [...] }
-#
-# BinaryExpression:
-#   { "type": "BinaryOp", "operator": "+", "left": <expr>, "right": <expr> }
-#
-# UnaryExpression:
-#   { "type": "UnaryOp", "operator": "-", "operand": <expr> }
-#
-# IntegerLiteral:
-#   { "type": "Integer", "value": 42 }
-#
-# Variable:
-#   { "type": "Variable", "name": "x" }
-#
-# Condition:
-#   { "type": "Condition", "operator": "<", "left": <expr>, "right": <expr> }
-#
-# ==============================================================================
-
-
-def parse(source_code: str) -> dict[str, Any]:
-    """
-    Parse source code into an AST.
-
-    Args:
-        source_code: The source code string to parse
-
-    Returns:
-        AST as a dictionary with the structure defined above
-
-    Raises:
-        SyntaxError: If the source code is invalid
-
-    Example:
-        >>> parse("x = 5;")
-        {
-            "type": "Program",
-            "statements": [
-                {
-                    "type": "Assignment",
-                    "variable": "x",
-                    "value": {"type": "Integer", "value": 5}
-                }
-            ]
-        }
-    """
-    # TODO: Implement this function
-    #
-    # Implementation hints:
-    # 1. Tokenize the source code (lexical analysis)
-    # 2. Build a recursive descent parser based on the grammar
-    # 3. Handle operator precedence correctly (* / before + -)
-    # 4. Return the AST as a dictionary
-    #
-    raise NotImplementedError("Parser not yet implemented - this is your task!")
-
-
-# ==============================================================================
-# Optional: Helper classes for implementation
+# Token Class
 # ==============================================================================
 
 
@@ -103,6 +30,11 @@ class Token:
         return f"Token({self.type}, {self.value!r})"
 
 
+# ==============================================================================
+# Lexer (Tokenizer)
+# ==============================================================================
+
+
 class Lexer:
     """
     Tokenizer for SimpleCalc language.
@@ -111,37 +43,369 @@ class Lexer:
         INTEGER, IDENTIFIER,
         PLUS, MINUS, STAR, SLASH,
         LPAREN, RPAREN, LBRACE, RBRACE,
-        ASSIGN, SEMICOLON, COMMA,
+        ASSIGN, SEMICOLON,
         EQ, NE, LT, GT, LE, GE,
         IF, ELSE, PRINT,
         EOF
     """
 
+    KEYWORDS = {"if", "else", "print"}
+
     def __init__(self, source: str):
         self.source = source
         self.pos = 0
         self.line = 1
         self.col = 1
 
+    def _current_char(self) -> str | None:
+        """Return current character or None if at end."""
+        if self.pos >= len(self.source):
+            return None
+        return self.source[self.pos]
+
+    def _peek_char(self) -> str | None:
+        """Peek at next character without consuming."""
+        if self.pos + 1 >= len(self.source):
+            return None
+        return self.source[self.pos + 1]
+
+    def _advance(self) -> str | None:
+        """Consume and return current character."""
+        ch = self._current_char()
+        if ch is not None:
+            self.pos += 1
+            if ch == "\n":
+                self.line += 1
+                self.col = 1
+            else:
+                self.col += 1
+        return ch
+
+    def _skip_whitespace(self):
+        """Skip whitespace characters."""
+        while self._current_char() is not None and self._current_char() in " \t\n\r":
+            self._advance()
+
+    def _skip_comment(self):
+        """Skip // style comments."""
+        if self._current_char() == "/" and self._peek_char() == "/":
+            while self._current_char() is not None and self._current_char() != "\n":
+                self._advance()
+            if self._current_char() == "\n":
+                self._advance()
+
+    def _read_integer(self) -> Token:
+        """Read an integer literal."""
+        start_line, start_col = self.line, self.col
+        result = ""
+        while self._current_char() is not None and self._current_char().isdigit():
+            result += self._advance()
+        return Token("INTEGER", int(result), start_line, start_col)
+
+    def _read_identifier(self) -> Token:
+        """Read an identifier or keyword."""
+        start_line, start_col = self.line, self.col
+        result = ""
+        while self._current_char() is not None and (
+            self._current_char().isalnum() or self._current_char() == "_"
+        ):
+            result += self._advance()
+
+        # Check if it's a keyword
+        if result in self.KEYWORDS:
+            return Token(result.upper(), result, start_line, start_col)
+        return Token("IDENTIFIER", result, start_line, start_col)
+
     def tokenize(self) -> list[Token]:
         """Convert source code into a list of tokens."""
-        # TODO: Implement tokenization
-        raise NotImplementedError()
+        tokens = []
+
+        while self._current_char() is not None:
+            # Skip whitespace
+            self._skip_whitespace()
+            if self._current_char() is None:
+                break
+
+            # Skip comments
+            if self._current_char() == "/" and self._peek_char() == "/":
+                self._skip_comment()
+                continue
+
+            start_line, start_col = self.line, self.col
+            ch = self._current_char()
+
+            # Integer
+            if ch.isdigit():
+                tokens.append(self._read_integer())
+            # Identifier or keyword
+            elif ch.isalpha() or ch == "_":
+                tokens.append(self._read_identifier())
+            # Two-character operators
+            elif ch == "=" and self._peek_char() == "=":
+                self._advance()
+                self._advance()
+                tokens.append(Token("EQ", "==", start_line, start_col))
+            elif ch == "!" and self._peek_char() == "=":
+                self._advance()
+                self._advance()
+                tokens.append(Token("NE", "!=", start_line, start_col))
+            elif ch == "<" and self._peek_char() == "=":
+                self._advance()
+                self._advance()
+                tokens.append(Token("LE", "<=", start_line, start_col))
+            elif ch == ">" and self._peek_char() == "=":
+                self._advance()
+                self._advance()
+                tokens.append(Token("GE", ">=", start_line, start_col))
+            # Single-character operators
+            elif ch == "=":
+                self._advance()
+                tokens.append(Token("ASSIGN", "=", start_line, start_col))
+            elif ch == "<":
+                self._advance()
+                tokens.append(Token("LT", "<", start_line, start_col))
+            elif ch == ">":
+                self._advance()
+                tokens.append(Token("GT", ">", start_line, start_col))
+            elif ch == "+":
+                self._advance()
+                tokens.append(Token("PLUS", "+", start_line, start_col))
+            elif ch == "-":
+                self._advance()
+                tokens.append(Token("MINUS", "-", start_line, start_col))
+            elif ch == "*":
+                self._advance()
+                tokens.append(Token("STAR", "*", start_line, start_col))
+            elif ch == "/":
+                self._advance()
+                tokens.append(Token("SLASH", "/", start_line, start_col))
+            elif ch == "(":
+                self._advance()
+                tokens.append(Token("LPAREN", "(", start_line, start_col))
+            elif ch == ")":
+                self._advance()
+                tokens.append(Token("RPAREN", ")", start_line, start_col))
+            elif ch == "{":
+                self._advance()
+                tokens.append(Token("LBRACE", "{", start_line, start_col))
+            elif ch == "}":
+                self._advance()
+                tokens.append(Token("RBRACE", "}", start_line, start_col))
+            elif ch == ";":
+                self._advance()
+                tokens.append(Token("SEMICOLON", ";", start_line, start_col))
+            else:
+                raise SyntaxError(
+                    f"Unexpected character '{ch}' at line {self.line}, col {self.col}"
+                )
+
+        tokens.append(Token("EOF", None, self.line, self.col))
+        return tokens
+
+
+# ==============================================================================
+# Parser (Recursive Descent)
+# ==============================================================================
 
 
 class Parser:
     """
     Recursive descent parser for SimpleCalc language.
+
+    Grammar:
+        program     = statement_list
+        statement   = assignment_stmt | print_stmt | if_stmt
+        assignment  = IDENTIFIER "=" expression ";"
+        print_stmt  = "print" "(" expression ")" ";"
+        if_stmt     = "if" "(" condition ")" "{" statement_list "}" ["else" "{" statement_list "}"]
+        condition   = expression comparison_op expression
+        expression  = term { ("+" | "-") term }
+        term        = factor { ("*" | "/") factor }
+        factor      = INTEGER | IDENTIFIER | "(" expression ")" | "-" factor
     """
 
     def __init__(self, tokens: list[Token]):
         self.tokens = tokens
         self.pos = 0
 
+    def _current(self) -> Token:
+        """Return current token."""
+        return self.tokens[self.pos]
+
+    def _peek(self) -> Token:
+        """Peek at current token without consuming."""
+        return self._current()
+
+    def _advance(self) -> Token:
+        """Consume and return current token."""
+        token = self._current()
+        if token.type != "EOF":
+            self.pos += 1
+        return token
+
+    def _expect(self, token_type: str) -> Token:
+        """Expect and consume a specific token type."""
+        token = self._current()
+        if token.type != token_type:
+            raise SyntaxError(
+                f"Expected {token_type}, got {token.type} at line {token.line}, col {token.col}"
+            )
+        return self._advance()
+
+    def _match(self, *types: str) -> bool:
+        """Check if current token matches any of the given types."""
+        return self._current().type in types
+
     def parse_program(self) -> dict:
         """Parse the entire program."""
-        # TODO: Implement parsing
-        raise NotImplementedError()
+        statements = self._parse_statement_list()
+        return {"type": "Program", "statements": statements}
+
+    def _parse_statement_list(self) -> list[dict]:
+        """Parse a list of statements."""
+        statements = []
+        while not self._match("EOF", "RBRACE"):
+            statements.append(self._parse_statement())
+        return statements
+
+    def _parse_statement(self) -> dict:
+        """Parse a single statement."""
+        if self._match("IF"):
+            return self._parse_if_statement()
+        elif self._match("PRINT"):
+            return self._parse_print_statement()
+        elif self._match("IDENTIFIER"):
+            return self._parse_assignment_statement()
+        else:
+            raise SyntaxError(
+                f"Unexpected token {self._current().type} at line {self._current().line}"
+            )
+
+    def _parse_assignment_statement(self) -> dict:
+        """Parse: IDENTIFIER = expression ;"""
+        var_token = self._expect("IDENTIFIER")
+        self._expect("ASSIGN")
+        value = self._parse_expression()
+        self._expect("SEMICOLON")
+        return {"type": "Assignment", "variable": var_token.value, "value": value}
+
+    def _parse_print_statement(self) -> dict:
+        """Parse: print ( expression ) ;"""
+        self._expect("PRINT")
+        self._expect("LPAREN")
+        value = self._parse_expression()
+        self._expect("RPAREN")
+        self._expect("SEMICOLON")
+        return {"type": "Print", "value": value}
+
+    def _parse_if_statement(self) -> dict:
+        """Parse: if ( condition ) { statements } [else { statements }]"""
+        self._expect("IF")
+        self._expect("LPAREN")
+        condition = self._parse_condition()
+        self._expect("RPAREN")
+        self._expect("LBRACE")
+        then_body = self._parse_statement_list()
+        self._expect("RBRACE")
+
+        else_body = []
+        if self._match("ELSE"):
+            self._advance()
+            self._expect("LBRACE")
+            else_body = self._parse_statement_list()
+            self._expect("RBRACE")
+
+        return {
+            "type": "If",
+            "condition": condition,
+            "then_body": then_body,
+            "else_body": else_body,
+        }
+
+    def _parse_condition(self) -> dict:
+        """Parse: expression comparison_op expression"""
+        left = self._parse_expression()
+
+        if not self._match("EQ", "NE", "LT", "GT", "LE", "GE"):
+            raise SyntaxError(f"Expected comparison operator, got {self._current().type}")
+
+        op_token = self._advance()
+        right = self._parse_expression()
+
+        return {"type": "Condition", "operator": op_token.value, "left": left, "right": right}
+
+    def _parse_expression(self) -> dict:
+        """Parse: term { ("+" | "-") term }"""
+        left = self._parse_term()
+
+        while self._match("PLUS", "MINUS"):
+            op_token = self._advance()
+            right = self._parse_term()
+            left = {"type": "BinaryOp", "operator": op_token.value, "left": left, "right": right}
+
+        return left
+
+    def _parse_term(self) -> dict:
+        """Parse: factor { ("*" | "/") factor }"""
+        left = self._parse_factor()
+
+        while self._match("STAR", "SLASH"):
+            op_token = self._advance()
+            right = self._parse_factor()
+            left = {"type": "BinaryOp", "operator": op_token.value, "left": left, "right": right}
+
+        return left
+
+    def _parse_factor(self) -> dict:
+        """Parse: INTEGER | IDENTIFIER | "(" expression ")" | "-" factor"""
+        if self._match("INTEGER"):
+            token = self._advance()
+            return {"type": "Integer", "value": token.value}
+
+        elif self._match("IDENTIFIER"):
+            token = self._advance()
+            return {"type": "Variable", "name": token.value}
+
+        elif self._match("LPAREN"):
+            self._advance()
+            expr = self._parse_expression()
+            self._expect("RPAREN")
+            return expr
+
+        elif self._match("MINUS"):
+            self._advance()
+            operand = self._parse_factor()
+            return {"type": "UnaryOp", "operator": "-", "operand": operand}
+
+        else:
+            raise SyntaxError(
+                f"Unexpected token {self._current().type} in expression"
+                f"at line {self._current().line}"
+            )
+
+
+# ==============================================================================
+# Main Parse Function
+# ==============================================================================
+
+
+def parse(source_code: str) -> dict[str, Any]:
+    """
+    Parse source code into an AST.
+
+    Args:
+        source_code: The source code string to parse
+
+    Returns:
+        AST as a dictionary with the structure defined in grammar.ebnf
+
+    Raises:
+        SyntaxError: If the source code is invalid
+    """
+    lexer = Lexer(source_code)
+    tokens = lexer.tokenize()
+    parser = Parser(tokens)
+    return parser.parse_program()
 
 
 # ==============================================================================
