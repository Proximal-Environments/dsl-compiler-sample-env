# ============================================================================
# EBNF Grammar for SimpleCalc Language
# ============================================================================
# This grammar defines a simple imperative language with:
#   - Integer arithmetic
#   - Variables
#   - Assignment
#   - Print statements
#   - If-else control flow
# ============================================================================

# ============================================================================
# LEXICAL RULES (Tokens)
# ============================================================================

INTEGER     = [0-9]+ ;
IDENTIFIER  = [a-zA-Z_][a-zA-Z0-9_]* ;
WHITESPACE  = [ \t\n\r]+ ;          # Ignored between tokens
COMMENT     = "//" [^\n]* "\n" ;    # Line comments, ignored

# ============================================================================
# GRAMMAR RULES
# ============================================================================

program     = statement_list ;

statement_list 
            = { statement } ;

statement   = assignment_stmt
            | print_stmt
            | if_stmt
            ;

# Assignment: variable = expression ;
assignment_stmt 
            = IDENTIFIER "=" expression ";" ;

# Print: print(expression) ;
print_stmt  = "print" "(" expression ")" ";" ;

# If-else: if (condition) { statements } [else { statements }]
if_stmt     = "if" "(" condition ")" "{" statement_list "}" 
              [ "else" "{" statement_list "}" ] ;

# Condition (comparison)
condition   = expression comparison_op expression ;

comparison_op 
            = "==" | "!=" | "<" | ">" | "<=" | ">=" ;

# ============================================================================
# EXPRESSION RULES (with operator precedence)
# ============================================================================
# Precedence (lowest to highest):
#   1. Addition, Subtraction (+, -)
#   2. Multiplication, Division (*, /)
#   3. Unary minus (-)
#   4. Parentheses, Literals, Variables

expression  = term { ("+" | "-") term } ;

term        = factor { ("*" | "/") factor } ;

factor      = INTEGER
            | IDENTIFIER
            | "(" expression ")"
            | "-" factor
            ;

# ============================================================================
# SEMANTIC NOTES
# ============================================================================
# 
# 1. All variables must be assigned before use
# 2. All arithmetic is integer arithmetic (division truncates)
# 3. Division by zero is undefined behavior
# 4. Variables are global scope
# 5. The final state includes all variable values and printed outputs
#
# ============================================================================
# OPERATOR MEANINGS
# ============================================================================
#
# Arithmetic Operators:
#   +   Addition (e.g., 3 + 4 = 7)
#   -   Subtraction (e.g., 10 - 3 = 7)
#   *   Multiplication (e.g., 3 * 4 = 12)
#   /   Integer Division (e.g., 7 / 2 = 3, truncates toward zero)
#
# Comparison Operators (used in conditions):
#   ==  Equal to
#   !=  Not equal to
#   <   Less than
#   >   Greater than
#   <=  Less than or equal to
#   >=  Greater than or equal to
#
# ============================================================================
# AST NODE TYPES (Expected output from parser)
# ============================================================================
# 
# The parser should produce an AST with these node types:
#
# Program:
#   { "type": "Program", "statements": [...] }
#
# AssignmentStatement:
#   { "type": "Assignment", "variable": "x", "value": <expression> }
#
# PrintStatement:
#   { "type": "Print", "value": <expression> }
#
# IfStatement:
#   { "type": "If", "condition": <condition>, "then_body": [...], "else_body": [...] }
#
# BinaryExpression:
#   { "type": "BinaryOp", "operator": "+", "left": <expr>, "right": <expr> }
#
# UnaryExpression:
#   { "type": "UnaryOp", "operator": "-", "operand": <expr> }
#
# IntegerLiteral:
#   { "type": "Integer", "value": 42 }
#
# Variable:
#   { "type": "Variable", "name": "x" }
#
# Condition:
#   { "type": "Condition", "operator": "<", "left": <expr>, "right": <expr> }
#
# ============================================================================
