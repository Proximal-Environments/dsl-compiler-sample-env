# ============================================================================
# Instruction Set Architecture: SimpleVM
# ============================================================================
# A simple register-based virtual machine for the SimpleCalc language
# ============================================================================

# ============================================================================
# MACHINE CONFIGURATION
# ============================================================================

REGISTERS: 4          # R0, R1, R2, R3 (general purpose)
MEMORY_SIZE: 256      # 256 memory slots (addressable 0-255)
STACK_ENABLED: true   # Stack operations available
STACK_SIZE: 64        # Maximum stack depth

# ============================================================================
# INSTRUCTION FORMAT
# ============================================================================
# 
# Each instruction is on its own line:
#   OPCODE [ARG1] [ARG2] [ARG3]
#
# Arguments can be:
#   Rn      - Register (R0, R1, R2, R3)
#   #imm    - Immediate value (e.g., #42, #-5)
#   [addr]  - Memory address (e.g., [0], [100])
#   @Rn     - Memory address in register (indirect)
#   label:  - Label definition
#   label   - Label reference (for jumps)
#
# ============================================================================

# ============================================================================
# DATA MOVEMENT INSTRUCTIONS
# ============================================================================

LOAD Rd, #imm
    # Load immediate value into register
    # Example: LOAD R0, #42    ; R0 = 42

LOAD Rd, [addr]
    # Load value from memory address into register
    # Example: LOAD R0, [100]  ; R0 = memory[100]

LOAD Rd, @Rs
    # Load value from memory address stored in Rs into Rd
    # Example: LOAD R0, @R1    ; R0 = memory[R1]

STORE Rs, [addr]
    # Store register value to memory address
    # Example: STORE R0, [100] ; memory[100] = R0

STORE Rs, @Rd
    # Store Rs to memory address stored in Rd
    # Example: STORE R0, @R1   ; memory[R1] = R0

MOV Rd, Rs
    # Copy value from Rs to Rd
    # Example: MOV R0, R1      ; R0 = R1

# ============================================================================
# ARITHMETIC INSTRUCTIONS
# ============================================================================

ADD Rd, Rs1, Rs2
    # Rd = Rs1 + Rs2
    # Example: ADD R0, R1, R2  ; R0 = R1 + R2

ADD Rd, Rs, #imm
    # Rd = Rs + immediate
    # Example: ADD R0, R1, #5  ; R0 = R1 + 5

SUB Rd, Rs1, Rs2
    # Rd = Rs1 - Rs2
    # Example: SUB R0, R1, R2  ; R0 = R1 - R2

SUB Rd, Rs, #imm
    # Rd = Rs - immediate
    # Example: SUB R0, R1, #5  ; R0 = R1 - 5

MUL Rd, Rs1, Rs2
    # Rd = Rs1 * Rs2
    # Example: MUL R0, R1, R2  ; R0 = R1 * R2

MUL Rd, Rs, #imm
    # Rd = Rs * immediate
    # Example: MUL R0, R1, #5  ; R0 = R1 * 5

DIV Rd, Rs1, Rs2
    # Rd = Rs1 / Rs2 (integer division, truncates toward zero)
    # Example: DIV R0, R1, R2  ; R0 = R1 / R2

DIV Rd, Rs, #imm
    # Rd = Rs / immediate
    # Example: DIV R0, R1, #5  ; R0 = R1 / 5

NEG Rd, Rs
    # Rd = -Rs (negate)
    # Example: NEG R0, R1      ; R0 = -R1

# ============================================================================
# COMPARISON INSTRUCTIONS
# ============================================================================

CMP Rs1, Rs2
    # Compare Rs1 and Rs2, set internal flags
    # Flags: ZERO (if equal), NEG (if Rs1 < Rs2)
    # Example: CMP R0, R1

CMP Rs, #imm
    # Compare Rs with immediate value
    # Example: CMP R0, #10

# ============================================================================
# CONTROL FLOW INSTRUCTIONS
# ============================================================================

JMP label
    # Unconditional jump to label
    # Example: JMP loop_start

JEQ label
    # Jump if equal (ZERO flag set)
    # Example: JEQ equal_case

JNE label
    # Jump if not equal (ZERO flag not set)
    # Example: JNE not_equal_case

JLT label
    # Jump if less than (NEG flag set)
    # Example: JLT less_case

JGT label
    # Jump if greater than (neither ZERO nor NEG)
    # Example: JGT greater_case

JLE label
    # Jump if less than or equal (ZERO or NEG)
    # Example: JLE less_equal_case

JGE label
    # Jump if greater than or equal (ZERO or not NEG)
    # Example: JGE greater_equal_case

# ============================================================================
# STACK INSTRUCTIONS
# ============================================================================

PUSH Rs
    # Push register value onto stack
    # Example: PUSH R0

POP Rd
    # Pop value from stack into register
    # Example: POP R0

# ============================================================================
# I/O INSTRUCTIONS
# ============================================================================

PRINT Rs
    # Output the value in Rs (appends to output buffer)
    # Example: PRINT R0        ; outputs value of R0

# ============================================================================
# PROGRAM CONTROL
# ============================================================================

HALT
    # Stop execution
    # Must be at the end of every program

NOP
    # No operation (do nothing, useful for alignment)

# ============================================================================
# LABELS
# ============================================================================
#
# Labels are defined with a colon and can be jumped to:
#   loop_start:
#       ADD R0, R0, #1
#       CMP R0, #10
#       JLT loop_start
#
# ============================================================================

# ============================================================================
# EXAMPLE PROGRAM
# ============================================================================
#
# Calculate: result = (3 + 5) * 2
# 
#     LOAD R0, #3       ; R0 = 3
#     LOAD R1, #5       ; R1 = 5
#     ADD R2, R0, R1    ; R2 = R0 + R1 = 8
#     LOAD R3, #2       ; R3 = 2
#     MUL R0, R2, R3    ; R0 = R2 * R3 = 16
#     STORE R0, [0]     ; memory[0] = 16 (store result)
#     PRINT R0          ; output: 16
#     HALT
#
# Expected final state:
#   R0=16, R1=5, R2=8, R3=2
#   memory[0]=16
#   output=[16]
#
# ============================================================================

# ============================================================================
# MEMORY LAYOUT CONVENTION
# ============================================================================
#
# For the code generator, use this memory layout:
#   [0-63]    : Variable storage (map variable names to addresses)
#   [64-127]  : Temporary values during expression evaluation
#   [128-255] : Reserved for future use
#
# Variable address mapping should be deterministic:
#   First variable encountered → [0]
#   Second variable → [1]
#   etc.
#
# ============================================================================
